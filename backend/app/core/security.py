from passlib.context import CryptContext #for hashing passwords
from jose import JWTError, jwt #for creating and verifying JSON Web Tokens
from datetime import datetime, timedelta, timezone #for handling token expiration
from fastapi import Depends, HTTPException, Security, status #for handling dependencies and exceptions in FastAPI
from fastapi.security import OAuth2PasswordBearer, HTTPBearer #for handling OAuth2 authentication
import os

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto") #initialize password hashing context

SECRET_KEY = os.getenv("SECRET_KEY") #is the format of sectret key automatically generated by python or do we have to generate it ourselves? Ans: The SECRET_KEY is not automatically generated by Python. You need to generate it yourself and set it as an environment variable. You can use a secure random generator to create a strong secret key, such as using the `secrets` module in Python: Example: `import secrets; secret_key = secrets.token_hex(32)`
ALGORITHM = "HS256" #specify the algorithm used for encoding and decoding JWTs
ACCESS_TOKEN_EXPIRE_MINUTES = 300 #set the expiration time for access tokens
REFRESH_TOKEN_EXPIRE_DAYS = 7 #set the expiration time for refresh tokens

if not SECRET_KEY:
    raise RuntimeError("SECRET_KEY not set in environment")

security = HTTPBearer() #initialize HTTP Bearer authentication scheme, this is used to extract the token from the Authorization header in incoming requests

def hash_password(password: str):
    return pwd_context.hash(password) #hash the password using the defined password hashing context

def verify_password(plain_password: str, hashed_password: str):
    return pwd_context.verify(plain_password, hashed_password)

def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp":expire, "type":"access"})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) #create and return a JWT access token with the specified data and expiration time

def create_refresh_token(data: dict):
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(days= REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp":expire, "type":"refresh"})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM) #create and return a JWT refresh token with the specified data and expiration time

def get_current_admin(credentials = Security(security)):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        if payload.get("type") != "access":
            raise HTTPException(status_code=401, detail="Invalid token type")
        return payload
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid or expired token")